Podman Compatibility
====================

Kolla Ansible supports deployments with Podman.  Podman 4.9 renamed
some fields returned by ``podman inspect``.  ``PidMode`` became
``PidNS`` and ``CgroupnsMode`` became ``CgroupNS``.  Kolla Ansible now
accepts either name when comparing containers and passes the correct
``--pid`` and ``--cgroupns`` options to ``podman`` when creating
containers.

When using ``*_extra_volumes`` options, Kolla Ansible will automatically
create any missing host directories referenced by bind mounts with
permissions ``0755`` before starting containers.

Optional systemd management
---------------------------

By default Podman containers are managed directly by Kolla Ansible.
Set ``kolla_podman_use_systemd: true`` in ``/etc/kolla/globals.yml`` to
generate and enable systemd unit files for services. Unit files are
installed as ``/etc/systemd/system/container-<name>.service`` and allow
systemd to start containers during host boot.

Sequential container start
--------------------------

Systemd unit files generated by Podman use the naming pattern
``container-<name>.service``. Some services may only provide
``kolla-<name>-container.service`` alias units. The ``service-start-order``
role examines both forms and installs matching ``After=`` and
``Requires=`` directives so that services start sequentially according to
``kolla_service_start_priority``. Each service waits for the previous unit
to reach the ``active`` state and, if a container health check is defined,
for that check to succeed. The role installs a helper script at
``/usr/local/lib/kolla/wait-unit-and-container-healthy.sh`` to perform
these checks. When no health indicator exists the delay is controlled by
``kolla_grace_no_healthcheck`` (default 30 seconds). An additional
post-healthy delay may be configured via ``kolla_post_healthy_delay`` or
per-service variables suffixed with ``_post_healthy_delay``. This delay
applies even when a dependency reports healthy immediately and defaults to
zero.
The role reloads systemd after writing any drop-in files so that new
dependencies are applied immediately. It also stops containers that were
previously launched directly via Podman and restarts them under systemd.
This ensures dependencies such as databases and messaging back ends are
available before the corresponding API services are launched. Each
restart waits for the container to reach the ``running`` and ``healthy``
states before the next service begins. Containers already in a healthy
state are left running. If a service fails to become healthy within the
configured timeout the playbook fails rather than waiting indefinitely.
The timeout is governed by ``kolla_service_healthcheck_retries`` and
``kolla_service_healthcheck_delay``.

Handler auto-start
------------------

Containers recreated from Ansible handlers now start immediately using
the ``kolla_container`` action plugin unless ``defer_start: true`` is
specified. This avoids any reliance on systemd inside the container and
ensures that the ``kolla_container`` action plugin records the
normalised container name in the ``kolla_changed_containers`` fact. When
``wait: true`` is also passed the handler first ensures the container is
started and then waits for it to reach the running and healthy state
before continuing. The final ordered restart phase uses systemd when
available to sequence service dependencies. During this phase the
``service-start-order`` role consults the registry, stops any
Podman-started containers once and then starts them under systemd using
``systemctl start container-<name>.service``. This transfers control to
systemd so that start-order dependencies are honoured. Containers that
were already managed by systemd are restarted only when listed in
``kolla_changed_containers``; unchanged services are left running. The
role also merges this fact with any services whose start-order overrides
changed to determine the final restart list, so entries must be
underscore-normalised to match service names. All container creation or
start operations in roles must invoke the ``kolla_container`` module so
the action plugin can update ``kolla_changed_containers``. If a container
is started or modified without using ``kolla_container``, its
normalised name must be added manually to ``kolla_changed_containers`` so
that it is restarted during this phase.

Troubleshooting
---------------

The final restart sequence relies on systemd unit files when they are
present. If systemd is unavailable or fails to start a unit, Kolla
Ansible reloads systemd units, retries using ``podman start`` and reports
the original systemd failure along with service status and journal output
to aid debugging.

One-shot cleanup containers
---------------------------

Cleanup containers like ``neutron_ovs_cleanup`` are started as normal
services.  They run at boot and create a marker file
``/tmp/kolla/neutron_ovs_cleanup_marker/done`` so subsequent starts skip the
container until the host reboots. The container bind mounts the host
``/tmp`` directory; because ``/tmp`` is recreated on each boot, the container
creates ``/tmp/kolla`` with ``1777`` permissions and copies its cleanup
script to ``/tmp/kolla/neutron_ovs_cleanup`` every time it starts.
